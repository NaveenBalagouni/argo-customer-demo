apiVersion: v1
kind: ConfigMap
metadata:
  name: my-configmap
data:
  APP_ENV: "production"
  APP_DEBUG: "false"
  APP_PORT: "8080"
  
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---


# ---
# apiVersion: v1
# kind: Pod
# metadata:
#   name: nginx-pod-2
#   labels:
#     app: nginx
# spec:
#   containers:
#   - name: nginx
#     image: nginx:latest
#     ports:
#     - containerPort: 80
---
apiVersion: batch/v1
kind: Job
metadata:
  name: my-job
  # annotations:
  #   argocd.argoproj.io/hook: PostSync
    #argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  #ttlSecondsAfterFinished: 60
  template:
    metadata:
      labels:
        app: my-job
    spec:
      containers:
      - name: my-job-container
        image: busybox
        command: ["sh", "-c", "echo Hello Kubernetes! && sleep 60"]
      restartPolicy: OnFailure

---
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: app-rolling-sync-check
#   #namespace: argocd
# data:
#   get-argocd-app-status1.sh: |
#     #!/bin/bash

#     # Label to filter applications
#     LABEL_SELECTOR="for=jpmc"

#     # Get the list of Argo CD applications with the specific label using kubectl
#     applications=$(kubectl get applications.argoproj.io -l $LABEL_SELECTOR -o jsonpath='{.items[*].metadata.name}')

#     if [ -z "$applications" ]; then
#       echo "No applications found with label: $LABEL_SELECTOR"
#       exit 1
#     fi

#     # Loop through each application and fetch details
#     for app in $applications; do
#       if [[ "$app" == "sync-wave-one" || "$app" == "sync-wave-two" ]]; then

#         # Fetch required details using kubectl
#         appcreation=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.metadata.creationTimestamp}')
#         appdeployStartedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployStartedAt}')
#         appdeployedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployedAt}')
#         appfinishedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.operationState.finishedAt}')
#         appreconciledAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.reconciledAt}')
        
#         # Display the results
#         echo "$app | Creation Timestamp: $appcreation | Deploy Started At: $appdeployStartedAt | Deployed At: $appdeployedAt | Finished At: $appfinishedAt | reconciledAt : $appreconciledAt"
#       fi
#     done



# ---
# apiVersion: batch/v1
# kind: Job
# metadata:
#   name: argocd-rolling-sync-job
#   #namespace: argocd
#   annotations:
#     argocd.argoproj.io/hook: PostSync
#     #argocd.argoproj.io/hook-delete-policy: HookSucceeded
# spec:
#   template:
#     spec:
#       serviceAccountName: argocd-app-status-sa  # Use the ServiceAccount with permissions
#       containers:
#       - name: argocd-app-status
#         image: bitnami/kubectl:latest
#         command: ["/bin/bash", "/scripts/get-argocd-app-status1.sh"]
#         volumeMounts:
#         - name: script-volume
#           mountPath: /scripts
#           readOnly: true
#       restartPolicy: Never
#       volumes:
#       - name: script-volume
#         configMap:
#           name: app-rolling-sync-check
#           items:
#             - key: get-argocd-app-status1.sh
#               path: get-argocd-app-status1.sh
#   backoffLimit: 1

# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: app-rolling-sync-check
#   namespace: argocd
# data:
#   get-argocd-app-status1.sh: |
#     #!/bin/bash

#     # Label to filter applications
#     LABEL_SELECTOR="for=jpmc"

#     # Get the list of Argo CD applications with the specific label using kubectl
#     applications=$(kubectl get applications.argoproj.io -l $LABEL_SELECTOR -o jsonpath='{.items[*].metadata.name}')

#     if [ -z "$applications" ]; then
#       echo "No applications found with label: $LABEL_SELECTOR"
#       exit 1
#     fi

#     # Loop through each application and fetch details
#     for app in $applications; do
#       if [[ "$app" == "sync-wave-one" || "$app" == "sync-wave-two" ]]; then

#         # Fetch required details using kubectl
#         appcreation=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.metadata.creationTimestamp}')
#         appdeployStartedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployStartedAt}')
#         appdeployedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployedAt}')
#         appfinishedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.operationState.finishedAt}')
        
#         # Display the results
#         echo "$app | Creation Timestamp: $appcreation | Deploy Started At: $appdeployStartedAt | Deployed At: $appdeployedAt | Finished At: $appfinishedAt"
#       fi
#     done


# ---
# apiVersion: batch/v1
# kind: Job
# metadata:
#   name: argocd-rolling-sync-job
#   namespace: argocd
# spec:
#   template:
#     spec:
#       serviceAccountName: argocd-app-status-sa  # Use the ServiceAccount with permissions
#       containers:
#       - name: argocd-app-status
#         image: bitnami/kubectl:latest
#         command: ["/bin/bash", "/scripts/get-argocd-app-status1.sh"]
#         volumeMounts:
#         - name: script-volume
#           mountPath: /scripts
#           readOnly: true
#       restartPolicy: Never
#       volumes:
#       - name: script-volume
#         configMap:
#           name: app-rolling-sync-check
#           items:
#             - key: get-argocd-app-status1.sh
#               path: get-argocd-app-status1.sh
#   backoffLimit: 1

