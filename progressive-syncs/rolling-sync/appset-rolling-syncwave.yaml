
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: appset-rolling-sync
  namespace: argocd

spec:
  generators:
  - git:
      files:
      - path: sync-wave/*/config.json
      repoURL: https://github.com/OpsMx/argo-customer-demo.git
      revision: test
  strategy:
    type: RollingSync
    rollingSync:
      steps:
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - zero
          maxUpdate: 100%
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - one
          maxUpdate: 100%
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - two
          maxUpdate: 100%
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - three
          maxUpdate: 100%
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - four
          maxUpdate: 100%
        - matchExpressions:
            - key: syncWave
              operator: In
              values: 
                - nine
          maxUpdate: 100%
          
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]
  template:
    metadata:
      name: sync-wave-{{ .name}}
      labels:
        for: jpmc
    spec:
      destination:
        name: in-cluster
        namespace: '{{ .namespace}}'
      project: default
      sources:
        - repoURL: '{{ .repoURL}}'
          targetRevision: '{{ .targetRevision}}'
          chart: '{{ .chart}}'
          ref: '{{ .ref}}'
        - repoURL: https://github.com/OpsMx/argo-customer-demo.git
          targetRevision: test
          path: pod-cm
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
        syncOptions:
          - CreateNamespace=true
          - ServerSideApply=true
      # syncPolicy:
      #   automated:
      #     #allowEmpty: true
      #     prune: true
      #     selfHeal: true 
      #   retry:
      #     backoff:
      #       duration: 60s
      #       factor: 2
      #       maxDuration: 2m
      #     limit: 10
      #   syncOptions:
      #   - CreateNamespace=true
      #   - ServerSideApply=true

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: argocd
  name: argocd-app-patch-role
rules:
  - apiGroups: ["argoproj.io"]
    resources: ["applications"]
    verbs: ["patch", "update"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  namespace: argocd
  name: argocd-app-patch-rolebinding
subjects:
  - kind: ServiceAccount
    name: argocd-app-status-sa
    namespace: argocd
roleRef:
  kind: Role
  name: argocd-app-patch-role
  apiGroup: rbac.authorization.k8s.io

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-rolling-sync-check
  namespace: argocd
data:
  get-argocd-app-status1.sh: |
    #!/bin/bash

    # Label to filter applications
    LABEL_SELECTOR="for=jpmc"

    # Get the list of Argo CD applications with the specific label using kubectl
    applications=$(kubectl get applications.argoproj.io -l $LABEL_SELECTOR -o jsonpath='{.items[*].metadata.name}')

    if [ -z "$applications" ]; then
      echo "No applications found with label: $LABEL_SELECTOR"
      exit 1
    fi

    # Loop through each application and fetch details
    for app in $applications; do
      if [[ "$app" == "sync-wave-one" || "$app" == "sync-wave-two" ]]; then
        # Enable auto-sync for the application
        echo "Enabling auto-sync for application: $app"
        kubectl patch application.argoproj.io "$app" --type merge -p '{"spec": {"syncPolicy": {"automated": {"prune": true, "selfHeal": true}}}}'

        # Fetch required details using kubectl
        appcreation=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.metadata.creationTimestamp}')
        appdeployStartedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployStartedAt}')
        appdeployedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployedAt}')
        appfinishedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.operationState.finishedAt}')
        appreconciledAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.reconciledAt}')
        
        # Display the results
        echo "$app | Creation Timestamp: $appcreation | Deploy Started At: $appdeployStartedAt | Deployed At: $appdeployedAt | Finished At: $appfinishedAt | Reconciled At: $appreconciledAt"
      fi
    done




---
apiVersion: batch/v1
kind: Job
metadata:
  name: argocd-rolling-sync-job
  namespace: argocd
  annotations:
    argocd.argoproj.io/hook: PostSync
    #argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      serviceAccountName: argocd-app-status-sa  # Use the ServiceAccount with permissions
      containers:
      - name: argocd-app-status
        image: bitnami/kubectl:latest
        command: ["/bin/bash", "/scripts/get-argocd-app-status1.sh"]
        volumeMounts:
        - name: script-volume
          mountPath: /scripts
          readOnly: true
      restartPolicy: Never
      volumes:
      - name: script-volume
        configMap:
          name: app-rolling-sync-check
          items:
            - key: get-argocd-app-status1.sh
              path: get-argocd-app-status1.sh
  backoffLimit: 1

