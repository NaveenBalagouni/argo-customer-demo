apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: guestbook
  namespace: argocd
spec:
  goTemplate: true
  generators:
  - list:
      elements:
      - cluster: engineering-dev
        url: https://kubernetes.default.svc
        foo: bar
      # Update foo value with foo: bar
      # Application engineering-prod-guestbook labels will change to foo: bar
      # Delete this element
      # Application engineering-prod-guestbook will be kept
      - cluster: engineering-prod
        url: https://test-vcluster.devops.opsmx.org:443
        foo: baz
  template:
    metadata:
      name: '{{.cluster}}-guestbook'
      labels:
        foo: '{{.foo}}'
    spec:
      project: default
      source:
        repoURL: https://github.com/OpsMx/argo-customer-demo.git
        targetRevision: test
        path: applicationset/guestbook/{{.cluster}}
      destination:
        server: '{{.url}}'
        namespace: guestbook
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
        syncOptions:
          - CreateNamespace=true
  #syncPolicy:
    #applicationsSync: create-update
# ---
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: app-rolling-sync-check-guetbook
#   namespace: argocd
# data:
#   get-argocd-app-rolling-guetbook.sh: |
#     #!/bin/bash

#     # Define the applications to monitor
#     APPLICATIONS=("engineering-dev-guestbook" "engineering-prod-guestbook")

#     # Check for status of each application until all conditions are met
#     #kubectl patch application.argoproj.io engineering-dev-guestbook engineering-prod-guestbook --type merge -p '{"spec": {"syncPolicy": {"automated": {"prune": true, "selfHeal": true}}}}'
    
#     while true; do
#       all_synced=true

#       for app in "${APPLICATIONS[@]}"; do
#         # Fetch application statuses
        
#         healthStatus=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.health.status}')
#         syncStatus=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.sync.status}')
#         lastSyncResult=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.operationState.phase}')

#         # Check if the status is as expected
#         if [[ "$healthStatus" == "Healthy" && "$syncStatus" == "Synced" && "$lastSyncResult" == "Succeeded" ]]; then
#           #completionTime=$(date '+%Y-%m-%d %H:%M:%S')
#           echo "Application $app is Healthy, Synced, and Last Sync is OK"
#         else
#           echo "Application $app is not in the desired state. Health: $healthStatus, Sync: $syncStatus, Last Sync: $lastSyncResult"
#           all_synced=false
#           break
#         fi
#         # Fetch required details using kubectl
#         appcreation=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.metadata.creationTimestamp}')
#         appdeployStartedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployStartedAt}')
#         appdeployedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.history[0].deployedAt}')
#         appfinishedAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.operationState.finishedAt}')
#         appreconciledAt=$(kubectl get application.argoproj.io "$app" -o jsonpath='{.status.reconciledAt}')
        
#         # Display the results
#         echo "$app | Creation Timestamp: $appcreation | Deploy Started At: $appdeployStartedAt | Deployed At: $appdeployedAt | Finished At: $appfinishedAt | Reconciled At: $appreconciledAt"
#       done

#       # If all applications are in the desired state, exit the loop
#       if [ "$all_synced" == true ]; then
#         echo "All applications are in the desired state."
#         break
#       else
#         echo "Waiting for applications to reach the desired state..."
#       fi

#       # Wait before checking again
#       sleep 30
#     done

# ---
# apiVersion: batch/v1
# kind: Job
# metadata:
#   name: argocd-rolling-sync-job-guetbook
#   namespace: argocd
#   annotations:
#     argocd.argoproj.io/hook: PostSync
#     #argocd.argoproj.io/hook-delete-policy: HookSucceeded
# spec:
#   template:
#     spec:
#       serviceAccountName: rolling-sync-app-status-sa
#       containers:
#       - name: argocd-app-rolling-sync
#         image: bitnami/kubectl:latest
#         command: ["/bin/bash", "/rolling-scripts-guetbook/get-argocd-app-rolling-guetbook.sh"]
#         volumeMounts:
#         - name: script-volume-rolling-guetbook
#           mountPath: /rolling-scripts-guetbook
#           readOnly: true
#       restartPolicy: Never
#       volumes:
#       - name: script-volume-rolling-guetbook
#         configMap:
#           name: app-rolling-sync-check-guetbook
#           items:
#             - key: get-argocd-app-rolling-guetbook.sh
#               path: get-argocd-app-rolling-guetbook.sh
#   backoffLimit: 1
